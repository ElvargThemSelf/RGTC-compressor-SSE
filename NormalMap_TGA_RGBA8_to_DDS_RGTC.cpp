/*
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <assert.h>
#include <time.h>
#include <algorithm>
#include <vector>
#include <emmintrin.h>

typedef uint8_t byte;
typedef uint32_t dword;
typedef uint64_t uint64;

#define SHUF(i0, i1, i2, i3) _MM_SHUFFLE(i3, i2, i1, i0)

bool UseSSE;

//------------------------------------------------------------------------------------
//                              mipmap generation
//------------------------------------------------------------------------------------

void GenerateMipMap2x2_Gen(const byte *srcPtr, int srcStride, int halfWidth, int halfHeight, byte *dstPtr, int dstStride) {
    for (int i = 0; i < halfHeight; i++) {
        const byte *inRow0 = &srcPtr[(2*i+0) * srcStride];
        const byte *inRow1 = &srcPtr[(2*i+1) * srcStride];
        byte *outRow = &dstPtr[i * dstStride];

        for (int j = 0; j < halfWidth; j++) {
            unsigned sum0 = (unsigned)inRow0[8*j+0] + inRow0[8*j+4+0] + inRow1[8*j+0] + inRow1[8*j+4+0];
            unsigned sum1 = (unsigned)inRow0[8*j+1] + inRow0[8*j+4+1] + inRow1[8*j+1] + inRow1[8*j+4+1];
            unsigned sum2 = (unsigned)inRow0[8*j+2] + inRow0[8*j+4+2] + inRow1[8*j+2] + inRow1[8*j+4+2];
            unsigned sum3 = (unsigned)inRow0[8*j+3] + inRow0[8*j+4+3] + inRow1[8*j+3] + inRow1[8*j+4+3];
            outRow[4*j+0] = (sum0 + 2) >> 2;
            outRow[4*j+1] = (sum1 + 2) >> 2;
            outRow[4*j+2] = (sum2 + 2) >> 2;
            outRow[4*j+3] = (sum3 + 2) >> 2;
        }
    }
}

void GenerateMipMap2x2_SSE2(const byte *srcPtr, int srcStride, int halfWidth, int halfHeight, byte *dstPtr, int dstStride) {
    for (int i = 0; i < halfHeight; i++) {
        const byte *inRow0 = &srcPtr[(2*i+0) * srcStride];
        const byte *inRow1 = &srcPtr[(2*i+1) * srcStride];
        byte *outRow = &dstPtr[i * dstStride];

        int j;
        for (j = 0; j + 4 <= halfWidth; j += 4) {
            __m128i A0 = _mm_loadu_si128((__m128i*)(inRow0 + 8*j + 0));
            __m128i A1 = _mm_loadu_si128((__m128i*)(inRow0 + 8*j + 16));
            __m128i B0 = _mm_loadu_si128((__m128i*)(inRow1 + 8*j + 0));
            __m128i B1 = _mm_loadu_si128((__m128i*)(inRow1 + 8*j + 16));

            __m128i A0shuf = _mm_shuffle_epi32(A0, SHUF(0, 2, 1, 3));
            __m128i A1shuf = _mm_shuffle_epi32(A1, SHUF(0, 2, 1, 3));
            __m128i B0shuf = _mm_shuffle_epi32(B0, SHUF(0, 2, 1, 3));
            __m128i B1shuf = _mm_shuffle_epi32(B1, SHUF(0, 2, 1, 3));
            __m128i A0l = _mm_unpacklo_epi8(A0shuf, _mm_setzero_si128());
            __m128i A0r = _mm_unpackhi_epi8(A0shuf, _mm_setzero_si128());
            __m128i A1l = _mm_unpacklo_epi8(A1shuf, _mm_setzero_si128());
            __m128i A1r = _mm_unpackhi_epi8(A1shuf, _mm_setzero_si128());
            __m128i B0l = _mm_unpacklo_epi8(B0shuf, _mm_setzero_si128());
            __m128i B0r = _mm_unpackhi_epi8(B0shuf, _mm_setzero_si128());
            __m128i B1l = _mm_unpacklo_epi8(B1shuf, _mm_setzero_si128());
            __m128i B1r = _mm_unpackhi_epi8(B1shuf, _mm_setzero_si128());

            __m128i sum0 = _mm_add_epi16(_mm_add_epi16(A0l, A0r), _mm_add_epi16(B0l, B0r));
            __m128i sum1 = _mm_add_epi16(_mm_add_epi16(A1l, A1r), _mm_add_epi16(B1l, B1r));
            __m128i avg0 = _mm_srli_epi16(_mm_add_epi16(sum0, _mm_set1_epi16(2)), 2);
            __m128i avg1 = _mm_srli_epi16(_mm_add_epi16(sum1, _mm_set1_epi16(2)), 2);

            __m128i res = _mm_packus_epi16(avg0, avg1);
            _mm_storeu_si128((__m128i*)(outRow + 4*j), res);
        }

        for (; j < halfWidth; j++) {
            unsigned sum0 = (unsigned)inRow0[8*j+0] + inRow0[8*j+4+0] + inRow1[8*j+0] + inRow1[8*j+4+0];
            unsigned sum1 = (unsigned)inRow0[8*j+1] + inRow0[8*j+4+1] + inRow1[8*j+1] + inRow1[8*j+4+1];
            unsigned sum2 = (unsigned)inRow0[8*j+2] + inRow0[8*j+4+2] + inRow1[8*j+2] + inRow1[8*j+4+2];
            unsigned sum3 = (unsigned)inRow0[8*j+3] + inRow0[8*j+4+3] + inRow1[8*j+3] + inRow1[8*j+4+3];
            outRow[4*j+0] = (sum0 + 2) >> 2;
            outRow[4*j+1] = (sum1 + 2) >> 2;
            outRow[4*j+2] = (sum2 + 2) >> 2;
            outRow[4*j+3] = (sum3 + 2) >> 2;
        }
    }
}

byte *GenerateMipMap(const byte *data, int width, int height) {
    int nw = std::max(width >> 1, 1);
    int nh = std::max(height >> 1, 1);
    byte *res = (byte*)malloc(nw * nh * 4);

    if (width == 1 || height == 1) {
        int pixels = width * height;
        for (int i = 0; i < pixels/2; i++)
            for (int c = 0; c < 4; c++) {
                unsigned sum = (unsigned)data[8*i+c] + data[8*i+4+c];
                res[4*i+c] = (sum + 1) >> 1;
            }
    }
    else {
        if (UseSSE)
            GenerateMipMap2x2_SSE2(data, width*4, nw, nh, res, nw*4);
        else
            GenerateMipMap2x2_Gen(data, width*4, nw, nh, res, nw*4);
    }

    return res;
}

//------------------------------------------------------------------------------------
//                              RGTC compression
//------------------------------------------------------------------------------------

void CompressRGTCFromRGBA8_Gen(const byte *srcPtr, int width, int height, int stride, byte *dstPtr) {
    int bw = (width + 3) / 4;
    int bh = (height + 3) / 4;
    uint64 *dstBlocks = (uint64*)dstPtr;
    byte block[4][4];

    for (int brow = 0; brow < bh; brow++) {
        for (int bcol = 0; bcol < bw; bcol++) {
            for (int comp = 0; comp < 2; comp++) {

                // load block
                for (int r = 0; r < 4; r++)
                    for (int c = 0; c < 4; c++) {
                        int i = brow * 4 + r;
                        int j = bcol * 4 + c;
                        // use "clamp" continuation
                        if (i > height - 1)
                            i = height - 1;
                        if (j > width - 1)
                            j = width - 1;
                        block[r][c] = srcPtr[i * stride + 4 * j + comp];
                    }

                // compute min/max
                int minv = block[0][0];
                int maxv = block[0][0];
                for (int r = 0; r < 4; r++)
                    for (int c = 0; c < 4; c++) {
                        minv = std::min(minv, (int)block[r][c]);
                        maxv = std::max(maxv, (int)block[r][c]);
                    }
                // be sure min < max, so that 7-step case is used
                if (minv == maxv) {
                    if (maxv < 255)
                        maxv++;
                    else
                        minv--;
                }

                uint64 blockData = maxv + (minv << 8);
                int bits = 16;
                for (int r = 0; r < 4; r++)
                    for (int c = 0; c < 4; c++) {
                        // compute ratio
                        int numer = block[r][c] - minv;
                        int denom = maxv - minv;
                        #if 0
                        // find closest ramp point
                        int idx = (numer * 7 + (denom >> 1)) / denom;
                        #else
                        // this code yields closest ramp point in most cases
                        // among all 32K ratios D/N, there are 258 exceptions with N >= 65
                        // in exceptional cases, ratio is close to middle, and chosen ramp point is almost as close
                        // Note: this code is used here to match CompressRGTCFromRGBA8_Kernel8x4 !
                        int mult = ((7 << 12) + denom-1) / denom;
                        int idx = (mult * numer + (1 << 11)) >> 12;
                        #endif
                        // convert to DXT5 index
                        int val = 8 - idx;
                        if (idx == 7)
                            val = 0;
                        if (idx == 0)
                            val = 1;
                        //append to bit stream
                        blockData += uint64(val) << bits;
                        bits += 3;
                    }
                assert(bits == 64);

                *dstBlocks++ = blockData;
            }
        }
    }
}

static void CompressRGTCFromRGBA8_Kernel8x4( const byte *srcPtr, int stride, byte *dstPtr ) {
    // Load rows and remove blue/alpha channels
    __m128i rgrg0, rgrg1, rgrg2, rgrg3;
    #define LOADROW(r) {\
        __m128i rgbaBlock0 = _mm_loadu_si128((__m128i*)(srcPtr + r * stride + 0)); \
        __m128i rgbaBlock1 = _mm_loadu_si128((__m128i*)(srcPtr + r * stride + 16)); \
        rgrg##r = _mm_xor_si128( \
            _mm_slli_epi32(rgbaBlock1, 16), \
            _mm_and_si128(rgbaBlock0, _mm_set1_epi32(0xFFFF)) \
        );\
    }
    LOADROW(0)
    LOADROW(1)
    LOADROW(2)
    LOADROW(3)
    #undef LOADROW

    // Compute min/max values
    __m128i minBytes = _mm_min_epu8(_mm_min_epu8(rgrg0, rgrg1), _mm_min_epu8(rgrg2, rgrg3));
    __m128i maxBytes = _mm_max_epu8(_mm_max_epu8(rgrg0, rgrg1), _mm_max_epu8(rgrg2, rgrg3));
    minBytes = _mm_min_epu8(minBytes, _mm_shuffle_epi32(minBytes, SHUF(2, 3, 0, 1)));
    maxBytes = _mm_max_epu8(maxBytes, _mm_shuffle_epi32(maxBytes, SHUF(2, 3, 0, 1)));
    minBytes = _mm_min_epu8(minBytes, _mm_shuffle_epi32(minBytes, SHUF(1, 0, 1, 0)));
    maxBytes = _mm_max_epu8(maxBytes, _mm_shuffle_epi32(maxBytes, SHUF(1, 0, 1, 0)));
    // (each 32-bit element contains min/max in RGRG format)

    // Make sure min != max
    __m128i deltaBytes = _mm_sub_epi8(maxBytes, minBytes);
    __m128i maskDeltaZero = _mm_cmpeq_epi8(deltaBytes, _mm_setzero_si128());
    maxBytes = _mm_sub_epi8(maxBytes, maskDeltaZero);
    deltaBytes = _mm_sub_epi8(deltaBytes, maskDeltaZero);
    __m128i maskMaxOverflown = _mm_and_si128(maskDeltaZero, _mm_cmpeq_epi8(maxBytes, _mm_setzero_si128()));
    minBytes = _mm_add_epi8(minBytes, maskMaxOverflown);
    maxBytes = _mm_add_epi8(maxBytes, maskMaxOverflown);

    // Prepare multiplier
    __m128i deltaDwords = _mm_unpacklo_epi8(deltaBytes, _mm_setzero_si128());
    deltaDwords = _mm_unpacklo_epi16(deltaDwords, _mm_setzero_si128());
    __m128 deltaFloat = _mm_cvtepi32_ps(deltaDwords);
    __m128 multFloat = _mm_div_ps(_mm_set1_ps(7 << 12), deltaFloat);
    __m128i multWords = _mm_cvttps_epi32(_mm_add_ps(multFloat, _mm_set1_ps(0.999f)));
    multWords = _mm_packs_epi32(multWords, multWords);

    __m128i chunksRow0, chunksRow1, chunksRow2, chunksRow3;
    #define PROCESS_ROW(r) { \
        /* Compute ratio, find closest ramp point */ \
        __m128i numerBytes = _mm_sub_epi8(rgrg##r, minBytes); \
        __m128i numerWords0 = _mm_unpacklo_epi8(numerBytes, _mm_setzero_si128()); \
        __m128i numerWords1 = _mm_unpackhi_epi8(numerBytes, _mm_setzero_si128()); \
        __m128i fixedQuot0 = _mm_mullo_epi16(numerWords0, multWords); \
        __m128i fixedQuot1 = _mm_mullo_epi16(numerWords1, multWords); \
        __m128i idsWords0 = _mm_srli_epi16(_mm_add_epi16(fixedQuot0, _mm_set1_epi16(1 << 11)), 12); \
        __m128i idsWords1 = _mm_srli_epi16(_mm_add_epi16(fixedQuot1, _mm_set1_epi16(1 << 11)), 12); \
        __m128i idsBytes = _mm_packs_epi16(idsWords0, idsWords1); \
        /* Convert ramp point index to DXT index */ \
        __m128i dxtIdsBytes = _mm_sub_epi8(_mm_set1_epi8(8), idsBytes); \
        dxtIdsBytes = _mm_add_epi8(dxtIdsBytes, _mm_cmpeq_epi8(idsBytes, _mm_set1_epi8(7))); \
        dxtIdsBytes = _mm_sub_epi8(dxtIdsBytes, _mm_and_si128(_mm_cmpeq_epi8(idsBytes, _mm_setzero_si128()), _mm_set1_epi8(7))); \
        /* Compress 3-bit indices into row 12-bit chunks */ \
        __m128i temp = dxtIdsBytes; \
        temp = _mm_xor_si128(temp, _mm_srli_epi64(temp, 32 - 3)); \
        __m128i tempLo = _mm_unpacklo_epi8(temp, _mm_setzero_si128()); \
        __m128i tempHi = _mm_unpackhi_epi8(temp, _mm_setzero_si128()); \
        temp = _mm_xor_si128(tempLo, _mm_slli_epi16(tempHi, 6)); \
        temp = _mm_unpacklo_epi16(temp, _mm_setzero_si128()); \
        temp = _mm_and_si128(temp, _mm_set1_epi32((1 << 12) - 1)); \
        chunksRow##r = temp; \
    }
    PROCESS_ROW(0)
    PROCESS_ROW(1)
    PROCESS_ROW(2)
    PROCESS_ROW(3)
    #undef PROCESS_ROW

    // Compress 12-bit row chunks into (16+32)-bit block chunks
    __m128i blockLow32 = _mm_xor_si128(_mm_slli_epi32(chunksRow0, 16), _mm_slli_epi32(chunksRow1, 28));
    __m128i blockHigh32 = _mm_xor_si128(_mm_slli_epi32(chunksRow2, 8), _mm_slli_epi32(chunksRow3, 20));
    blockHigh32 = _mm_xor_si128(blockHigh32, _mm_srli_epi32(chunksRow1, 4));
    // Add max/min bytes to first 16 bits
    __m128i maxMinDwords = _mm_unpacklo_epi8(maxBytes, minBytes);
    maxMinDwords = _mm_unpacklo_epi16(maxMinDwords, _mm_setzero_si128());
    blockLow32 = _mm_xor_si128(blockLow32, maxMinDwords);

    // Write out two blocks
    __m128i block0 = _mm_unpacklo_epi32(blockLow32, blockHigh32);
    __m128i block1 = _mm_unpackhi_epi32(blockLow32, blockHigh32);
    _mm_storeu_si128((__m128i*)(dstPtr + 0), block0);
    _mm_storeu_si128((__m128i*)(dstPtr + 16), block1);
}

void CompressRGTCFromRGBA8_SSE2(const byte *srcPtr, int width, int height, int stride, byte *dstPtr) {
    dword inputBlocks[4][8];
    __m128i outputBlocks[2];

    for (int sr = 0; sr < height; sr += 4) {
        int fitsNum = (sr + 4 <= height ? width >> 3 : 0);

        int iters;
        for (iters = 0; iters < fitsNum; iters++) {
            // Load blocks directly from image memory
            CompressRGTCFromRGBA8_Kernel8x4(&srcPtr[sr * stride + 32 * iters], stride, dstPtr);
            dstPtr += 32;
        }

        for (int sc = 8 * iters; sc < width; sc += 8) {
            // Copy blocks with clamp-style padding
            for (int i = 0; i < 4; i++)
                for (int j = 0; j < 8; j++) {
                    int a = sr + i;
                    int b = sc + j;
                    if (a > height - 1)
                        a = height - 1;
                    if (b > width - 1)
                        b = width - 1;
                    inputBlocks[i][j] = *(dword*)&srcPtr[a * stride + 4 * b];
                }
            CompressRGTCFromRGBA8_Kernel8x4((byte*)&inputBlocks[0][0], sizeof(inputBlocks[0]), (byte*)outputBlocks);
            // Copy one or two blocks to output
            int numBlocks = std::min((width - sc + 3) >> 2, 2);
            for (int b = 0; b < numBlocks; b++) {
                _mm_storeu_si128((__m128i*)dstPtr, outputBlocks[b]);
                dstPtr += 16;
            }
        }
    }
}

//------------------------------------------------------------------------------------
//                       Full compression and mipmaps generation
//------------------------------------------------------------------------------------

struct MipmapLevel {
    byte *data;
    int width, height;
    int sizeInBytes;
};

std::vector<MipmapLevel> CompressAndGenerateMipmaps(const byte *data, int width, int height) {
    std::vector<MipmapLevel> result;

    const byte *srcData = data;
    int levw = width;
    int levh = height;

    // Generate mipmaps and compress them
    while (1) {
        int bw = (levw + 3) >> 2;
        int bh = (levh + 3) >> 2;

        byte *dstData = (byte*)malloc(bw * bh * 16);
        if (UseSSE)
            CompressRGTCFromRGBA8_SSE2(srcData, levw, levh, 4 * levw, dstData);
        else
            CompressRGTCFromRGBA8_Gen(srcData, levw, levh, 4 * levw, dstData);

        MipmapLevel mip = {dstData, levw, levh, bw * bh * 16};
        result.push_back(mip);

        if (levw == 1 && levh == 1)
            break;

        byte *newMip = GenerateMipMap(srcData, levw, levh);
        levw = std::max(levw >> 1, 1);
        levh = std::max(levh >> 1, 1);

        if (srcData != data)
            free((byte*)srcData);
        srcData = newMip;
    } 
    if (srcData != data)
        free((byte*)srcData);

    return result;
}

//------------------------------------------------------------------------------------
//                                 TGA reader
//------------------------------------------------------------------------------------

#pragma pack(push, 1)
typedef struct TgaImageSpecs {
    uint16_t originX;
    uint16_t originY;
    uint16_t width;
    uint16_t height;
    uint8_t bpp;
    uint8_t desc;
} TgaImageSpecs;
typedef struct TgaHeader {
    uint8_t identificationLength;
    uint8_t colorMapType;
    uint8_t imageTypeCode;
    char colorMapSpecs[5];
    TgaImageSpecs imageSpecs; 
} TgaHeader;
#pragma pack(pop)

void ReadTGA(const char *filename, byte* &data, int &width, int &height) {
    FILE *fin = fopen(filename, "rb");
    assert(fin);

    TgaHeader tgaHeader;
    fread(&tgaHeader, sizeof(TgaHeader), 1, fin);

    //no color map in the file
    assert(tgaHeader.colorMapType == 0);
    //true-color RGB without RLE compression
    assert(tgaHeader.imageTypeCode == 2);
    //only 32-bit RGBA images and 24-bit RGB images are supported
    assert(tgaHeader.imageSpecs.bpp == 32 || tgaHeader.imageSpecs.bpp == 24);
    //only old Truevision images supported, no way to set order of lines
    assert((tgaHeader.imageSpecs.desc & 0xF0) == 0);

    width = tgaHeader.imageSpecs.width;
    height = tgaHeader.imageSpecs.height;
    data = (byte*)malloc(width * height * 4);

    int bpp = tgaHeader.imageSpecs.bpp / 8;
    fread(data, width * height * bpp, 1, fin);

    for (int i = width * height - 1; i >= 0; i--) {
        data[4*i+0] = data[bpp*i+0];
        data[4*i+1] = data[bpp*i+1];
        data[4*i+2] = data[bpp*i+2];
        data[4*i+3] = 255;
        std::swap(data[4*i+0], data[4*i+2]);
    }

    fclose(fin);
}

//------------------------------------------------------------------------------------
//                                 DDS writer
//------------------------------------------------------------------------------------

struct DdsPixelformat {
  dword dwSize;
  dword dwFlags;
  dword dwFourCC;
  dword dwRGBBitCount;
  dword dwRBitMask;
  dword dwGBitMask;
  dword dwBBitMask;
  dword dwABitMask;
};
struct DdsHeader {
  dword           dwSize;
  dword           dwFlags;
  dword           dwHeight;
  dword           dwWidth;
  dword           dwPitchOrLinearSize;
  dword           dwDepth;
  dword           dwMipMapCount;
  dword           dwReserved1[11];
  DdsPixelformat  ddspf;
  dword           dwCaps;
  dword           dwCaps2;
  dword           dwCaps3;
  dword           dwCaps4;
  dword           dwReserved2;
};
enum DdsFlags {
    DDSF_CAPS           = 0x00000001,
    DDSF_HEIGHT         = 0x00000002,
    DDSF_WIDTH          = 0x00000004,
    DDSF_PIXELFORMAT    = 0x00001000,
    DDSF_MIPMAPCOUNT    = 0x00020000,
    DDSF_LINEARSIZE     = 0x00080000,
    DDSF_FOURCC         = 0x00000004,
    DDSF_COMPLEX        = 0x00000008,
    DDSF_TEXTURE        = 0x00001000,
    DDSF_MIPMAP         = 0x00400000,
};

void WriteDDS(const char *filename, const std::vector<MipmapLevel> &levels) {
    FILE *fout = fopen(filename, "wb");
    assert(fout);

    fwrite("DDS ", 4, 1, fout);

    DdsHeader header;
    memset(&header, 0, sizeof(header));
    header.dwSize = sizeof(header);
    header.dwFlags = DDSF_CAPS | DDSF_PIXELFORMAT | DDSF_WIDTH | DDSF_HEIGHT;
    header.dwFlags |= DDSF_LINEARSIZE | DDSF_MIPMAPCOUNT;
    header.dwWidth = levels[0].width;
    header.dwHeight = levels[0].height;
    header.dwPitchOrLinearSize = levels[0].sizeInBytes;
    header.dwMipMapCount = levels.size();
    header.ddspf.dwSize = sizeof(header.ddspf);
    header.ddspf.dwFlags = DDSF_FOURCC;
    memcpy(&header.ddspf.dwFourCC, "ATI2", 4);
    header.dwCaps = DDSF_TEXTURE | DDSF_MIPMAP | DDSF_COMPLEX;

    fwrite(&header, sizeof(header), 1, fout);

    for (int lvl = 0; lvl < levels.size(); lvl++)
        fwrite(levels[lvl].data, levels[lvl].sizeInBytes, 1, fout);

    fclose(fout);
}

//------------------------------------------------------------------------------------
//                                 entry point
//------------------------------------------------------------------------------------

int main(int argc, char **argv) {
    if (argc < 2) {
        fprintf(stderr, "Parameters:  inputfilename.tga outputfilename.dds {--gen} {--sse} {--repeat K}\n");
        fprintf(stderr, "   --gen        use generic code: slow and simple one\n");
        fprintf(stderr, "   --sse        use SSE2 code: the fast one (default)\n");
        fprintf(stderr, "   --repeat K   repeat compression K times and display average time\n");
        return 123;
    }

    UseSSE = true;
    int repeat = 1;
    std::vector<const char *> positional;

    for (int i = 1; i < argc; i++) {
        if (strcmp(argv[i], "--gen") == 0)
            UseSSE = false;
        else if (strcmp(argv[i], "--sse") == 0)
            UseSSE = true;
        else if (strcmp(argv[i], "--repeat") == 0)
            repeat = atoi(argv[++i]);
        else
            positional.push_back(argv[i]);
    }
    if (positional.size() != 2) {
        fprintf(stderr, "Wrong number of positional arguments (or unknown option)\n");
        return 111;
    }

    byte *data = 0;
    int width = 0, height = 0;

    ReadTGA(positional[0], data, width, height);

    std::vector<MipmapLevel> levels;
    int startTime = clock();
    for (int i = 0; i < repeat; i++)
        levels = CompressAndGenerateMipmaps(data, width, height);
    int deltaTime = clock() - startTime;

    WriteDDS(positional[1], levels);

    printf("Running %s code %d times took %0.2lf milliseconds\n", (UseSSE ? "SSE-accelerated" : "generic"), repeat, 1e+3 * deltaTime / CLOCKS_PER_SEC);

    return 0;
}
